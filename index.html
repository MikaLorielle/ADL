<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spin Recorder ‚Äî ORCatLang</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  body { background: linear-gradient(135deg,#2e026d,#d63384); min-height:100vh; color:white; }
  .center-wrap { display:flex; align-items:center; justify-content:center; flex-direction:column; gap:16px; padding:28px; }
  #output-wrap { display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center; }
  #output-gif { width:256px; height:256px; background:transparent; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.4); }
  #gif-progress { background: rgba(0,0,0,0.5); padding:8px 12px; border-radius:10px; font-size:14px; }
  #startBtn, #downloadBtn { cursor:pointer; }
  /* small header */
  header { padding:12px 18px; display:flex; align-items:center; justify-content:space-between; gap:12px; background: rgba(255,255,255,0.04); backdrop-filter:blur(8px); border-radius:10px; margin:12px; }
  #logo-sequence { width:40px; height:40px; border-radius:8px; background:transparent; }
</style>
</head>
<body>
  <header>
    <div style="display:flex;align-items:center;gap:12px;">
      <img id="logo-sequence" src="ORCC.png" alt="logo">
      <h1 style="margin:0;font-size:18px;color:#fbcfe8;">ORCatLang ‚Äî Spin Recorder</h1>
    </div>
    <div style="display:flex;gap:10px;align-items:center;">
      <button id="startBtn" class="px-4 py-2 rounded-full bg-pink-500 hover:bg-pink-600">Start Recording</button>
      <button id="downloadBtn" class="px-4 py-2 rounded-full bg-purple-600 hover:bg-purple-700" style="display:none">Download GIF</button>
    </div>
  </header>

  <main class="center-wrap">
    <div style="max-width:900px;width:100%;text-align:center">
      <p style="margin:0 0 12px 0; color:#ffd6f0">Records a single loop (logo ‚Üí üêà ‚Üí ü©∑ ‚Üí logo), 30 fps, 512√ó512, then shows & downloads the GIF.</p>
    </div>

    <div id="output-wrap" class="w-full max-w-md">
      <div id="gif-progress" style="display:none">Idle</div>
      <img id="output-gif" alt="Your generated GIF will appear here" />
      <small style="opacity:0.85;color:#ffd6f0">If download doesn‚Äôt start automatically on iOS, long-press the GIF and save.</small>
    </div>
  </main>

  <!-- hidden offscreen canvas used to draw/encode -->
  <canvas id="offscreen" width="512" height="512" style="display:none"></canvas>

  <!-- gif.js (optimized) -->
  <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>

<script>
(async function(){
  const startBtn = document.getElementById('startBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const progressEl = document.getElementById('gif-progress');
  const outImg = document.getElementById('output-gif');
  const logoPreview = document.getElementById('logo-sequence');

  // CONFIG
  const CANVAS_SIZE = 512;
  const FPS = 30;
  const SPIN_SEC = 2.0;
  const PAUSE_SEC = 1.0;
  const FRAMES_PER_SPIN = Math.round(FPS * SPIN_SEC);
  const FRAMES_PAUSE = Math.round(FPS * PAUSE_SEC);
  const FRAME_DELAY_MS = Math.round(1000 / FPS);
  const logoSrc = 'Img.PNG';   // ensure this file is in the same folder on GitHub Pages
  const emojis = ['üêà', 'ü©∑'];

  // offscreen canvas context
  const off = document.getElementById('offscreen');
  off.width = CANVAS_SIZE;
  off.height = CANVAS_SIZE;
  const ctx = off.getContext('2d');

  // preload logo (DO NOT set crossOrigin for same-origin files on GitHub Pages)
  const logoImg = new Image();
  logoImg.src = logoSrc;

  // prepare emoji font
  const emojiFontPx = Math.floor(CANVAS_SIZE * 0.72) + 'px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif';

  function easeInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2*t)*t;
  }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  function drawContent(content, angleDeg) {
    ctx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
    ctx.save();
    ctx.translate(CANVAS_SIZE/2, CANVAS_SIZE/2);
    ctx.rotate(angleDeg * Math.PI/180);

    if (typeof content === 'string') {
      ctx.font = emojiFontPx;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'black';
      ctx.fillText(content, 0, 0);
    } else {
      try {
        ctx.drawImage(content, -CANVAS_SIZE/2, -CANVAS_SIZE/2, CANVAS_SIZE, CANVAS_SIZE);
      } catch (e) {
        // drawing might fail if image not loaded ‚Äî that's okay, fallback will render emoji frames still
        console.warn('drawImage issue (maybe not loaded yet):', e);
      }
    }

    ctx.restore();
  }

  // helper to fetch worker script and return blob url
  async function makeWorkerBlobUrl(workerScriptUrl) {
    try {
      const res = await fetch(workerScriptUrl);
      if (!res.ok) throw new Error('Worker fetch failed: ' + res.status);
      const text = await res.text();
      const blob = new Blob([text], { type: 'application/javascript' });
      return URL.createObjectURL(blob);
    } catch (err) {
      console.error('Failed to fetch worker script:', err);
      return null;
    }
  }

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    downloadBtn.style.display = 'none';
    progressEl.style.display = 'inline-block';
    progressEl.textContent = 'Preparing‚Ä¶';
    outImg.src = ''; // clear previous

    // wait briefly for logo to load (proceed even if it doesn't)
    if (!logoImg.complete) {
      await new Promise(res => {
        logoImg.onload = () => res();
        logoImg.onerror = () => { console.warn('Logo load failed ‚Äî continuing'); res(); };
        setTimeout(res, 2500);
      });
    }

    const sequence = [
      { start: logoImg, end: emojis[0] },   // logo -> cat
      { start: emojis[0], end: emojis[1] }, // cat -> heart
      { start: emojis[1], end: logoImg }    // heart -> logo
    ];

    // create worker blob URL (important on GitHub Pages/CDN)
    const workerUrl = await makeWorkerBlobUrl('https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js');
    if (!workerUrl) {
      progressEl.textContent = 'Failed to load GIF worker (check console).';
      startBtn.disabled = false;
      return;
    }

    // create GIF with workerScript set to the blob URL
    const gif = new GIF({
      workers: 2,
      quality: 1,
      width: CANVAS_SIZE,
      height: CANVAS_SIZE,
      transparent: 'rgba(0,0,0,0)',
      workerScript: workerUrl
    });

    // show progress during encoding so user isn't stuck on "Finalizing‚Ä¶"
    gif.on('progress', function(p) {
      const pct = Math.round(p * 100);
      progressEl.textContent = `Finalizing GIF‚Ä¶ ${pct}%`;
    });

    gif.on('error', function(err) {
      console.error('GIF error:', err);
      progressEl.textContent = 'GIF encoder error ‚Äî see console';
      startBtn.disabled = false;
    });

    gif.on('finished', function(blob) {
      progressEl.textContent = 'Completed';
      const url = URL.createObjectURL(blob);

      outImg.src = url;
      outImg.width = CANVAS_SIZE;
      outImg.height = CANVAS_SIZE;

      // attempt auto-download (should work on Android/Chrome); iOS may open in new tab
      const a = document.createElement('a');
      a.href = url;
      a.download = 'orcat_spin_512x512.gif';
      document.body.appendChild(a);
      a.click();
      a.remove();

      // manual fallback
      downloadBtn.style.display = 'inline-block';
      downloadBtn.onclick = () => {
        const b = document.createElement('a'); b.href = url; b.download = 'orcat_spin_512x512.gif'; document.body.appendChild(b); b.click(); b.remove();
      };

      setTimeout(()=>{ progressEl.style.display = 'none'; }, 1400);
      startBtn.disabled = false;
    });

    // add frames
    const totalFrames = sequence.length * (FRAMES_PER_SPIN + FRAMES_PAUSE);
    let addedFrames = 0;
    function addFrame(delay) {
      try {
        gif.addFrame(off, { copy: true, delay });
      } catch (e) {
        try { gif.addFrame(ctx, { copy: true, delay }); } catch (e2) { console.error('addFrame failure', e, e2); }
      }
      addedFrames++;
      const pct = Math.round((addedFrames / totalFrames) * 100);
      progressEl.textContent = `Recording GIF‚Ä¶ ${pct}%`;
    }

    for (let s=0; s<sequence.length; s++) {
      const pair = sequence[s];
      for (let f=0; f<FRAMES_PER_SPIN; f++) {
        const t = f / Math.max(1, FRAMES_PER_SPIN - 1);
        const eased = easeInOut(t);
        const angle = eased * 360.0;

        const content = angle >= 180.0 ? pair.end : pair.start;
        drawContent(content, angle);

        try { logoPreview.src = off.toDataURL('image/png'); } catch(e) { /* ignore taint if it occurs */ }

        addFrame(FRAME_DELAY_MS);
        await sleep(0);
      }

      // pause frames
      for (let p=0; p<FRAMES_PAUSE; p++) {
        drawContent(pair.end, 0);
        try { logoPreview.src = off.toDataURL('image/png'); } catch(e) {}
        addFrame(FRAME_DELAY_MS);
        await sleep(0);
      }
    }

    progressEl.textContent = 'Finalizing GIF‚Ä¶ 0%';
    try {
      gif.render();
    } catch (err) {
      console.error('gif.render() threw:', err);
      progressEl.textContent = 'GIF render failed ‚Äî see console';
      startBtn.disabled = false;
    }
  });
})();
</script>
</body>
</html>