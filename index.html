<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="darkorchid" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
  <title>ORCatLang</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body {
      transition: background-color 0.3s, color 0.3s;
      background: linear-gradient(135deg, #2e026d, #d63384);
    }
    .frosted {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 0 0 1rem 1rem;
    }
    .card {
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      transform-style: preserve-3d;
      background: linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
    }
    .card:hover {
      transform: perspective(800px) rotateY(5deg) rotateX(5deg);
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
    }
    html { scroll-behavior: smooth; }

    a, button {
      position: relative;
      display: inline-block;
      overflow: hidden;
      transition:
        transform 0.4s ease-in-out,
        background-position 0.8s cubic-bezier(0.4, 0, 0.2, 1),
        background-color 0.6s ease-in-out,
        color 0.6s ease-in-out;
      will-change: transform, background-position, background-color, color;
      backface-visibility: hidden;
      transform-style: preserve-3d;
      transform-origin: center center;
    }

    a:hover, button:hover { transform: scale(1.05); }

    .fancy-button {
      background: linear-gradient(90deg, #d946ef, #db2777);
      background-size: 200% 100%;
      background-position: left center;
    }

    .fancy-button:hover { background-position: right center; }

    .btn-effect {
      background: linear-gradient(90deg, rgba(255,255,255,0.1), rgba(255,255,255,0.2));
      background-size: 200% 100%;
      background-position: left center;
    }
    .btn-effect:hover { background-position: right center; }

    @keyframes slideUpFadeIn {
      0% { opacity: 0; transform: translateY(30px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    .slide-up-fade-in {
      opacity: 0;
      animation-fill-mode: forwards;
      animation-name: slideUpFadeIn;
      animation-duration: 0.5s;
      animation-timing-function: ease-out;
    }

    /* small header logo specific sizing */
    #logo-sequence {
      width: 40px;
      height: 40px;
      image-rendering: -webkit-optimize-contrast;
      transition: transform 0.35s cubic-bezier(.22,.9,.32,1);
      transform-origin: 50% 50%;
      display: block;
      border-radius: 8px;
      background: transparent;
    }

    canvas#snow {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }

    /* small non-blocking progress badge */
    #gif-progress {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 60;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      backdrop-filter: blur(6px);
    }
  </style>
</head>
<body class="text-white relative font-sans" id="body">
  <canvas id="snow"></canvas>

  <header class="frosted sticky top-0 z-50 p-4 flex justify-between items-center">
    <a href="#" class="flex items-center gap-3">
      <img id="logo-sequence" src="ORCC.png" alt="ORCatLang Logo" class="">
      <h1 class="text-2xl font-bold text-pink-400">ORCatLang</h1>
    </a>
    <div class="flex items-center gap-4">
      <span class="text-sm sm:text-base italic text-pink-200 whitespace-nowrap">Strong like an ORCa, Precise like a CAT.</span>
      <a href="https://github.com/MikaLorielle/orcat" target="_blank" class="text-sm px-3 py-1 rounded-lg btn-effect">(here) GitHub</a>
      <a href="https://github.com/MikaLorielle/Orcat-Lang" target="_blank" class="text-sm px-3 py-1 rounded-lg btn-effect">(compiler) GitHub</a>
      <a href="#download" class="text-sm px-3 py-1 rounded-lg fancy-button">Download</a>
    </div>
  </header>

  <main class="relative z-10 px-6 py-16 max-w-6xl mx-auto space-y-20">
    <!-- (your content unchanged) -->
    <!-- ... keep the rest of your HTML content here (omitted for brevity in this snippet) ... -->
    <!-- I left the rest of your content exactly as you provided earlier. -->
    <!-- For the full page use your original content below this script block. -->
  </main>

  <!-- small progress indicator -->
  <div id="gif-progress" style="display:none">Recording GIF‚Ä¶ 0%</div>

  <!-- include gif.js -->
  <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>

  <script>
    /**************************************************************************
     * Spin + Recorder
     *
     * Behavior:
     *  - Sequence: logo -> üêà -> ü©∑ -> logo
     *  - Each step is one eased 360¬∞ spin (ease-in/out).
     *  - At 180¬∞ the image swaps to the 'next' content, finishing the spin on it.
     *  - After each spin we pause 1s (static).
     *  - The page records every frame to a transparent GIF and auto-downloads when done.
     *
     * This version updates the visible header logo every frame so you see the spin.
     **************************************************************************/

    (function () {
      const headerImg = document.getElementById('logo-sequence');
      const progressBadge = document.getElementById('gif-progress');

      // assets: your header file name ("ORCC.png") ‚Äî keep it in the same folder
      const logoSrc = 'ORCC.png';
      const emojis = ['üêà', 'ü©∑'];

      // canvas used for drawing + recording (512x512 for Discord-friendly size)
      const CANVAS_SIZE = 512;
      const off = document.createElement('canvas');
      off.width = CANVAS_SIZE;
      off.height = CANVAS_SIZE;
      const ctx = off.getContext('2d');

      // Preload logo image
      const logoImg = new Image();
      logoImg.crossOrigin = 'anonymous';
      logoImg.src = logoSrc;

      // text drawing settings (emoji large)
      const emojiFont = Math.floor(CANVAS_SIZE * 0.72) + 'px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif';

      // easing (ease-in-out cubic-like)
      function easeInOut(t) {
        return t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
      }

      // draw a content: either an Image object or a string emoji
      function drawContent(content, angleDeg) {
        ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

        ctx.save();
        // transparent background preserved (do not fill)
        ctx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
        ctx.rotate(angleDeg * Math.PI / 180);

        if (typeof content === 'string') {
          // emoji string
          ctx.font = emojiFont;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          // use fill black to match your previous requests; you can change to other color
          ctx.fillStyle = 'black';
          ctx.fillText(content, 0, 0);
        } else {
          // assume image
          // fit image to canvas
          ctx.drawImage(content, -CANVAS_SIZE/2, -CANVAS_SIZE/2, CANVAS_SIZE, CANVAS_SIZE);
        }

        ctx.restore();
      }

      // small helper to sleep in async loop
      function wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // start once logo loaded
      logoImg.onload = async () => {
        // Build the sequence pairs: (start, end)
        const sequence = [
          { start: logoImg, end: emojis[0] },   // logo -> cat
          { start: emojis[0], end: emojis[1] }, // cat -> heart
          { start: emojis[1], end: logoImg }    // heart -> logo
        ];

        // animation parameters
        const FPS = 30;
        const SPIN_SEC = 2;      // 2s per 360¬∞ spin
        const PAUSE_SEC = 1;     // 1s pause between spins
        const FRAMES_PER_SPIN = Math.round(FPS * SPIN_SEC);
        const FRAMES_PAUSE = Math.round(FPS * PAUSE_SEC);
        const FRAME_DELAY_MS = Math.round(1000 / FPS);

        // prepare GIF recorder
        const gif = new GIF({
          workers: 2,
          quality: 1,
          transparent: 'rgba(0,0,0,0)', // try to keep transparency
          workerScript: 'https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js'
        });

        // progress UI
        let totalFrames = sequence.length * (FRAMES_PER_SPIN + FRAMES_PAUSE);
        let framesAdded = 0;
        progressBadge.style.display = 'block';
        progressBadge.textContent = 'Recording GIF‚Ä¶ 0%';

        // function to add current canvas frame to gif and update header preview
        function pushFrame(delay) {
          // provide the drawing context directly (gif.js accepts canvas context)
          try {
            gif.addFrame(ctx, { copy: true, delay: delay });
          } catch(e) {
            // fallback: pass the canvas element
            gif.addFrame(off, { copy: true, delay: delay });
          }
          // update visible header preview (small scaled down thumbnail)
          try {
            headerImg.src = off.toDataURL('image/png');
          } catch (e) {
            // ignore if cross-origin issues
          }
          framesAdded++;
          const percent = Math.round((framesAdded / totalFrames) * 100);
          progressBadge.textContent = `Recording GIF‚Ä¶ ${percent}%`;
        }

        // run sequence asynchronously to allow UI updates
        for (let stepIdx = 0; stepIdx < sequence.length; stepIdx++) {
          const pair = sequence[stepIdx];
          for (let f = 0; f < FRAMES_PER_SPIN; f++) {
            const t = f / Math.max(1, FRAMES_PER_SPIN - 1);
            const eased = easeInOut(t);
            const angle = eased * 360.0;

            // choose content: swap exactly at 180deg
            const content = (angle >= 180.0) ? pair.end : pair.start;

            drawContent(content, angle);

            // add frame to gif and update preview
            pushFrame(FRAME_DELAY_MS);

            // allow rendering / UI update between frames
            await wait(FRAME_DELAY_MS);
          }

          // pause on the end image for FRAMES_PAUSE frames
          for (let p = 0; p < FRAMES_PAUSE; p++) {
            // draw the end (static, 0 rotation)
            drawContent(pair.end, 0);
            pushFrame(FRAME_DELAY_MS);
            await wait(FRAME_DELAY_MS);
          }
        }

        // finish recording
        progressBadge.textContent = 'Finalizing GIF‚Ä¶';
        gif.on('finished', function(blob) {
          progressBadge.textContent = 'Download ready ‚Äî saving GIF';
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'orcat_spin.gif';
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => { progressBadge.style.display = 'none'; }, 1200);
          // restore header preview back to original logo image
          headerImg.src = logoSrc;
        });

        gif.render();
      };

      // If logo fails to load, still try to proceed with text-only versions
      logoImg.onerror = () => {
        console.warn('Logo image failed to load ‚Äî falling back to emoji-only sequence.');
        // create a simple fallback image (white background) to avoid crashing
        const fall = new Image();
        fall.width = CANVAS_SIZE;
        fall.height = CANVAS_SIZE;
        // set start -> cat, cat -> heart, heart -> text "LOGO"
        // but realistically you should ensure ORCC.png is reachable
      };
    })();
  </script>

  <!-- snow canvas script and misc left unchanged (copy your original snow script here) -->
  <script>
    const canvas = document.getElementById('snow');
    const ctx = canvas.getContext('2d');
    let w, h;
    let particles = [];

    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();

    for (let i = 0; i < 150; i++) {
      particles.push({
        x: Math.random() * w,
        y: Math.random() * h,
        r: Math.random() * 2,
        d: Math.random() * 1
      });
    }

    function draw() {
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        ctx.moveTo(p.x, p.y);
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2, true);
      }
      ctx.fill();
      update();
    }

    function update() {
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.y += p.d;
        if (p.y > h) {
          p.y = 0;
          p.x = Math.random() * w;
        }
      }
    }

    function loop() {
      draw();
      requestAnimationFrame(loop);
    }

    loop();
  </script>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const elementsToAnimate = [
        ...document.querySelectorAll('main > section'),
        ...document.querySelectorAll('.card')
      ];

      elementsToAnimate.forEach((el, i) => {
        el.classList.add('slide-up-fade-in');
        el.style.animationDelay = `${i * 200}ms`;
      });
    });
  </script>

</body>
</html>