<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spin Recorder ‚Äî ORCatLang</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  body { background: linear-gradient(135deg,#2e026d,#d63384); min-height:100vh; color:white; }
  .center-wrap { display:flex; align-items:center; justify-content:center; flex-direction:column; gap:16px; padding:28px; }
  #output-wrap { display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center; }
  #output-gif { width:256px; height:256px; background:transparent; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.4); }
  #gif-progress { background: rgba(0,0,0,0.5); padding:8px 12px; border-radius:10px; font-size:14px; }
  #startBtn, #downloadBtn { cursor:pointer; transition: transform 0.25s cubic-bezier(0.68,-0.55,0.27,1.55); }
  header { padding:12px 18px; display:flex; align-items:center; justify-content:space-between; gap:12px; background: rgba(255,255,255,0.04); backdrop-filter:blur(8px); border-radius:10px; margin:12px; }
  #logo-sequence { width:40px; height:40px; border-radius:8px; background:transparent; }
</style>
</head>
<body>
  <header>
    <div style="display:flex;align-items:center;gap:12px;">
      <img id="logo-sequence" src="ORCC.png" alt="logo">
      <h1 style="margin:0;font-size:18px;color:#fbcfe8;">ORCatLang ‚Äî Spin Recorder</h1>
    </div>
    <div style="display:flex;gap:10px;align-items:center;">
      <button id="startBtn" class="px-4 py-2 rounded-full bg-pink-500 hover:bg-pink-600">Start Recording</button>
      <button id="downloadBtn" class="px-4 py-2 rounded-full bg-purple-600 hover:bg-purple-700" style="display:none">Download GIF</button>
    </div>
  </header>

  <main class="center-wrap">
    <div style="max-width:900px;width:100%;text-align:center">
      <p style="margin:0 0 12px 0; color:#ffd6f0">Records a single loop (logo ‚Üí üêà ‚Üí ü©∑ ‚Üí logo), 30 fps, 512√ó512, then shows & downloads the GIF.</p>
    </div>

    <div id="output-wrap" class="w-full max-w-md">
      <div id="gif-progress" style="display:none">Idle</div>
      <img id="output-gif" alt="Your generated GIF will appear here" />
      <small style="opacity:0.85;color:#ffd6f0">If download doesn‚Äôt start automatically on iOS, long-press the GIF and save.</small>
    </div>
  </main>

  <canvas id="offscreen" width="512" height="512" style="display:none"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>

<script>
(async function(){
  const startBtn = document.getElementById('startBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const progressEl = document.getElementById('gif-progress');
  const outImg = document.getElementById('output-gif');
  const logoPreview = document.getElementById('logo-sequence');

  // CONFIG
  const CANVAS_SIZE = 512;
  const FPS = 30;
  const SPIN_SEC = 2.0;
  const PAUSE_SEC = 1.0;
  const PRESS_SEC = 0.4; // button press animation length
  const FRAMES_PER_SPIN = Math.round(FPS * SPIN_SEC);
  const FRAMES_PAUSE = Math.round(FPS * PAUSE_SEC);
  const FRAMES_PRESS = Math.round(FPS * PRESS_SEC);
  const FRAME_DELAY_MS = Math.round(1000 / FPS);
  const logoSrc = 'Img.PNG';
  const emojis = ['üêà', 'ü©∑'];

  // offscreen canvas
  const off = document.getElementById('offscreen');
  off.width = CANVAS_SIZE;
  off.height = CANVAS_SIZE;
  const ctx = off.getContext('2d');

  // preload logo
  const logoImg = new Image();
  logoImg.src = logoSrc;

  const emojiFontPx = Math.floor(CANVAS_SIZE * 0.72) + 'px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif';

  function easeInOutCubic(t) {
    return t < 0.5
      ? 4 * t * t * t
      : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  function renderContent(content, scale=1) {
    ctx.save();
    ctx.scale(scale, scale);
    if (typeof content === 'string') {
      ctx.font = emojiFontPx;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'black';
      ctx.fillText(content, 0, 0);
    } else {
      ctx.drawImage(content, -CANVAS_SIZE/2, -CANVAS_SIZE/2, CANVAS_SIZE, CANVAS_SIZE);
    }
    ctx.restore();
  }

  function drawCrossfade(startContent, endContent, progress, angle, scale=1) {
    ctx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
    ctx.save();
    ctx.translate(CANVAS_SIZE/2, CANVAS_SIZE/2);
    ctx.rotate(angle * Math.PI/180);
    ctx.scale(scale, scale);

    ctx.globalAlpha = 1 - progress;
    renderContent(startContent);
    ctx.globalAlpha = progress;
    renderContent(endContent);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  async function makeWorkerBlobUrl(workerScriptUrl) {
    try {
      const res = await fetch(workerScriptUrl);
      const text = await res.text();
      const blob = new Blob([text], { type: 'application/javascript' });
      return URL.createObjectURL(blob);
    } catch (err) {
      console.error('Failed to fetch worker script:', err);
      return null;
    }
  }

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    downloadBtn.style.display = 'none';
    progressEl.style.display = 'inline-block';
    progressEl.textContent = 'Preparing‚Ä¶';
    outImg.src = '';

    if (!logoImg.complete) {
      await new Promise(res => {
        logoImg.onload = () => res();
        logoImg.onerror = () => res();
        setTimeout(res, 2000);
      });
    }

    const sequence = [
      { start: logoImg, end: emojis[0] },
      { start: emojis[0], end: emojis[1] },
      { start: emojis[1], end: logoImg }
    ];

    const workerUrl = await makeWorkerBlobUrl('https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js');
    if (!workerUrl) {
      progressEl.textContent = 'Failed to load GIF worker.';
      startBtn.disabled = false;
      return;
    }

    const gif = new GIF({
      workers: 2,
      quality: 1,
      width: CANVAS_SIZE,
      height: CANVAS_SIZE,
      transparent: 'rgba(0,0,0,0)',
      workerScript: workerUrl
    });

    gif.on('progress', p => {
      const pct = Math.round(p * 100);
      progressEl.textContent = `Finalizing GIF‚Ä¶ ${pct}%`;
    });

    gif.on('finished', blob => {
      progressEl.textContent = 'Completed';
      const url = URL.createObjectURL(blob);
      outImg.src = url;
      outImg.width = CANVAS_SIZE;
      outImg.height = CANVAS_SIZE;

      const a = document.createElement('a');
      a.href = url;
      a.download = 'orcat_spin_512x512.gif';
      document.body.appendChild(a);
      a.click();
      a.remove();

      downloadBtn.style.display = 'inline-block';
      downloadBtn.onclick = () => {
        const b = document.createElement('a');
        b.href = url;
        b.download = 'orcat_spin_512x512.gif';
        document.body.appendChild(b);
        b.click();
        b.remove();
      };

      setTimeout(()=>{ progressEl.style.display = 'none'; }, 1400);
      startBtn.disabled = false;
    });

    // progress accounting
    const totalFrames = FRAMES_PRESS + sequence.length * (FRAMES_PER_SPIN + FRAMES_PAUSE);
    let addedFrames = 0;
    function addFrame(delay) {
      gif.addFrame(off, { copy: true, delay });
      addedFrames++;
      const pct = Math.round((addedFrames / totalFrames) * 100);
      progressEl.textContent = `Recording GIF‚Ä¶ ${pct}%`;
    }

    // --- PRESS IN/OUT ANIMATION ---
    for (let f=0; f<FRAMES_PRESS; f++) {
      const t = f / Math.max(1, FRAMES_PRESS - 1);
      const eased = easeInOutCubic(t);
      // scale: 1 ‚Üí 0.9 ‚Üí 1
      const scale = 1 - 0.1 * Math.sin(eased * Math.PI);
      ctx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
      ctx.save();
      ctx.translate(CANVAS_SIZE/2, CANVAS_SIZE/2);
      ctx.scale(scale, scale);
      renderContent(logoImg);
      ctx.restore();

      try { logoPreview.src = off.toDataURL('image/png'); } catch(e) {}
      addFrame(FRAME_DELAY_MS);
      await sleep(0);
    }

    // --- SPIN ANIMATION ---
    for (let s=0; s<sequence.length; s++) {
      const pair = sequence[s];
      for (let f=0; f<FRAMES_PER_SPIN; f++) {
        const t = f / Math.max(1, FRAMES_PER_SPIN - 1);
        const eased = easeInOutCubic(t);
        const angle = eased * 360;
        drawCrossfade(pair.start, pair.end, eased, angle);

        try { logoPreview.src = off.toDataURL('image/png'); } catch(e) {}
        addFrame(FRAME_DELAY_MS);
        await sleep(0);
      }
      for (let p=0; p<FRAMES_PAUSE; p++) {
        drawCrossfade(pair.end, pair.end, 1, 0);
        try { logoPreview.src = off.toDataURL('image/png'); } catch(e) {}
        addFrame(FRAME_DELAY_MS);
        await sleep(0);
      }
    }

    progressEl.textContent = 'Finalizing GIF‚Ä¶ 0%';
    try { gif.render(); }
    catch (err) {
      console.error('gif.render() threw:', err);
      progressEl.textContent = 'GIF render failed';
      startBtn.disabled = false;
    }
  });
})();
</script>
</body>
</html>