<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spin Recorder â€” ORCatLang</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  body {
    background: linear-gradient(135deg,#2e026d,#d63384);
    min-height:100vh;
    color:white;
    font-family: 'Poppins', sans-serif;
    overflow-x:hidden;
  }

  /* glowing animated background particles */
  body::before {
    content:"";
    position:fixed;
    top:0; left:0;
    width:100%; height:100%;
    background: radial-gradient(circle, rgba(255,255,255,0.05) 1px, transparent 1px) repeat;
    background-size: 50px 50px;
    animation: bgMove 20s linear infinite;
    z-index:-1;
  }
  @keyframes bgMove { 0%{background-position:0 0} 100%{background-position:50px 50px} }

  .center-wrap { display:flex; align-items:center; justify-content:center; flex-direction:column; gap:24px; padding:28px; }
  #output-wrap { display:flex; flex-direction:column; gap:12px; align-items:center; justify-content:center; }

  #output-gif {
    width:256px; height:256px;
    border-radius:24px;
    box-shadow: 0 12px 36px rgba(0,0,0,0.5), 0 0 20px rgba(255, 182, 193,0.5);
    background: radial-gradient(circle at 30% 30%, #fbcfe8, #d63384);
    transition: transform 0.4s ease;
  }

  #gif-progress {
    background: rgba(0,0,0,0.5);
    padding:10px 16px;
    border-radius:14px;
    font-size:15px;
    color:#fff;
    text-shadow: 0 0 5px rgba(0,0,0,0.5);
  }

  button {
    cursor:pointer;
    transition: transform 0.25s cubic-bezier(0.68,-0.55,0.27,1.55), background 0.3s;
    font-weight:600;
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  }
  button:hover { transform: scale(1.08); }
  #startBtn { background: linear-gradient(135deg,#f472b6,#d946ef); color:white; }
  #downloadBtn { background: linear-gradient(135deg,#8b5cf6,#9333ea); color:white; }

  header {
    padding:14px 20px;
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    background: rgba(255,255,255,0.06); backdrop-filter:blur(10px);
    border-radius:16px; margin:12px; box-shadow:0 8px 24px rgba(0,0,0,0.2);
  }

  #logo-sequence {
    width:50px; height:50px; border-radius:12px; transition: transform 0.4s ease;
  }

  .description {
    max-width:900px; width:100%; text-align:center;
    background: rgba(255,255,255,0.05); padding:14px 18px; border-radius:16px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    color:#ffd6f0;
  }

</style>
</head>
<body>
  <header>
    <div style="display:flex;align-items:center;gap:14px;">
      <img id="logo-sequence" src="ORCC.png" alt="logo">
      <h1 style="margin:0;font-size:20px;color:#fbcfe8;">ORCatLang â€” Spin Recorder</h1>
    </div>
    <div style="display:flex;gap:12px;align-items:center;">
      <button id="startBtn" class="px-5 py-3 rounded-full">Start Recording</button>
      <button id="downloadBtn" class="px-5 py-3 rounded-full" style="display:none">Download GIF</button>
    </div>
  </header>

  <main class="center-wrap">
    <div class="description">
      Records a single loop with smooth aesthetic transitions, 30 fps, 512Ã—512, then shows & downloads the GIF.
    </div>

    <div id="output-wrap" class="w-full max-w-md">
      <div id="gif-progress" style="display:none">Idle</div>
      <img id="output-gif" alt="Your generated GIF will appear here" />
      <small style="opacity:0.85;color:#ffd6f0">If download doesnâ€™t start automatically on iOS, long-press the GIF and save.</small>
    </div>
  </main>

  <canvas id="offscreen" width="512" height="512" style="display:none"></canvas>

<script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>
<script>
(async function(){
  const startBtn = document.getElementById('startBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const progressEl = document.getElementById('gif-progress');
  const outImg = document.getElementById('output-gif');
  const logoPreview = document.getElementById('logo-sequence');

  const CANVAS_SIZE = 512;
  const FPS = 30;
  const SPIN_SEC = 2.0;
  const PAUSE_SEC = 0.8;
  const PRESS_SEC = 0.4;
  const FRAMES_PER_SPIN = Math.round(FPS * SPIN_SEC);
  const FRAMES_PAUSE = Math.round(FPS * PAUSE_SEC);
  const FRAMES_PRESS = Math.round(FPS * PRESS_SEC);
  const FRAME_DELAY_MS = Math.round(1000 / FPS);
  const logoSrc = 'Img.PNG';
  const emojis = ['ðŸ˜º','ðŸ’–'];

  const off = document.getElementById('offscreen');
  off.width = CANVAS_SIZE; off.height = CANVAS_SIZE;
  const ctx = off.getContext('2d');

  const logoImg = new Image(); logoImg.src = logoSrc;
  const emojiFontPx = Math.floor(CANVAS_SIZE * 0.72) + 'px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif';

  function easeInOutCubic(t) { return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  function renderContent(content, scale=1) {
    ctx.save(); ctx.scale(scale,scale);
    if(typeof content==='string'){
      ctx.font = emojiFontPx; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='white'; ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=12;
      ctx.fillText(content,0,0);
    } else { ctx.drawImage(content,-CANVAS_SIZE/2,-CANVAS_SIZE/2,CANVAS_SIZE,CANVAS_SIZE); }
    ctx.restore();
  }

function drawCrossfade(startContent, endContent, progress, angle, scale=1){
    // Clear fully transparent
    ctx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE);

    // Draw the blended frame manually
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = CANVAS_SIZE; tempCanvas.height = CANVAS_SIZE;
    const tempCtx = tempCanvas.getContext('2d');

    // Draw start content
    tempCtx.save();
    tempCtx.translate(CANVAS_SIZE/2, CANVAS_SIZE/2);
    tempCtx.rotate(angle*Math.PI/180);
    tempCtx.scale(scale, scale);
    renderContentOnCtx(tempCtx, startContent);
    tempCtx.restore();

    // Draw end content
    tempCtx.save();
    tempCtx.translate(CANVAS_SIZE/2, CANVAS_SIZE/2);
    tempCtx.rotate(angle*Math.PI/180);
    tempCtx.scale(scale, scale);
    tempCtx.globalAlpha = progress;
    renderContentOnCtx(tempCtx, endContent);
    tempCtx.restore();

    // Copy to main canvas
    ctx.drawImage(tempCanvas, 0, 0);
}

// Helper function to draw content onto any context
function renderContentOnCtx(c, content, scale=1){
    c.save(); c.scale(scale, scale);
    if(typeof content==='string'){
        c.font = emojiFontPx;
        c.textAlign = 'center';
        c.textBaseline = 'middle';
        c.fillStyle = 'white';
        c.shadowColor='rgba(0,0,0,0.5)';
        c.shadowBlur=12;
        c.fillText(content, 0, 0);
    } else {
        c.drawImage(content, -CANVAS_SIZE/2, -CANVAS_SIZE/2, CANVAS_SIZE, CANVAS_SIZE);
    }
    c.restore();
}


  async function makeWorkerBlobUrl(workerScriptUrl){
    try{ const res = await fetch(workerScriptUrl); const text = await res.text(); return URL.createObjectURL(new Blob([text], {type:'application/javascript'})); }
    catch(err){ console.error(err); return null; }
  }

  startBtn.addEventListener('click', async()=>{
    startBtn.disabled=true; downloadBtn.style.display='none'; progressEl.style.display='inline-block'; progressEl.textContent='Preparingâ€¦'; outImg.src='';
    if(!logoImg.complete) await new Promise(r=>{ logoImg.onload=r; logoImg.onerror=r; setTimeout(r,2000); });

    const sequence = [ {start:logoImg,end:emojis[0]}, {start:emojis[0],end:emojis[1]}, {start:emojis[1],end:logoImg} ];
    const workerUrl = await makeWorkerBlobUrl('https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js');
    if(!workerUrl){ progressEl.textContent='Failed to load GIF worker.'; startBtn.disabled=false; return; }

    const gif = new GIF({workers:2,quality:1,width:CANVAS_SIZE,height:CANVAS_SIZE,transparent:'rgba(0,0,0,0)',workerScript:workerUrl});
    gif.on('progress',p=>progressEl.textContent=`Finalizing GIFâ€¦ ${Math.round(p*100)}%`);
    gif.on('finished',blob=>{
      progressEl.textContent='Completed';
      const url = URL.createObjectURL(blob);
      outImg.src=url; outImg.width=CANVAS_SIZE; outImg.height=CANVAS_SIZE;
      downloadBtn.style.display='inline-block';
      downloadBtn.onclick=()=>{ const a=document.createElement('a'); a.href=url; a.download='orcat_spin_512x512.gif'; document.body.appendChild(a); a.click(); a.remove(); };
      setTimeout(()=>progressEl.style.display='none',1400);
      startBtn.disabled=false;
    });

    const totalFrames = FRAMES_PRESS + sequence.length*(FRAMES_PER_SPIN+FRAMES_PAUSE); let addedFrames=0;
    function addFrame(delay){ gif.addFrame(off,{copy:true,delay}); addedFrames++; progressEl.textContent=`Recording GIFâ€¦ ${Math.round((addedFrames/totalFrames)*100)}%`; }

    for(let f=0;f<FRAMES_PRESS;f++){
      const t=f/Math.max(1,FRAMES_PRESS-1), eased=easeInOutCubic(t);
      const scale=1-0.12*Math.sin(eased*Math.PI); ctx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE); ctx.save(); ctx.translate(CANVAS_SIZE/2,CANVAS_SIZE/2); ctx.scale(scale,scale);
      renderContent(logoImg); ctx.restore(); try{ logoPreview.src=off.toDataURL('image/png'); }catch(e){}
      addFrame(FRAME_DELAY_MS); await sleep(0);
    }

    for(let s=0;s<sequence.length;s++){
      const pair=sequence[s];
      for(let f=0;f<FRAMES_PER_SPIN;f++){
        const t=f/Math.max(1,FRAMES_PER_SPIN-1), eased=easeInOutCubic(t), angle=eased*360, scale=1+0.05*Math.sin(eased*Math.PI*2);
        drawCrossfade(pair.start,pair.end,eased,angle,scale); try{ logoPreview.src=off.toDataURL('image/png'); }catch(e){} addFrame(FRAME_DELAY_MS); await sleep(0);
      }
      for(let p=0;p<FRAMES_PAUSE;p++){ drawCrossfade(pair.end,pair.end,1,0); try{ logoPreview.src=off.toDataURL('image/png'); }catch(e){} addFrame(FRAME_DELAY_MS); await sleep(0);}
    }

    progressEl.textContent='Finalizing GIFâ€¦ 0%'; try{ gif.render(); } catch(err){ console.error(err); progressEl.textContent='GIF render failed'; startBtn.disabled=false; }
  });
})();
</script>
</body>
</html>
